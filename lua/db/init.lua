---
--- Generated by LuaDB(https://github.com/limao996/LuaDB)
--- Created by 狸猫呐.
--- DateTime: 2023/6/26 16:26
---

local db = { ver = 32, BIT_16 = 2, BIT_24 = 3, BIT_32 = 4, BIT_48 = 6, BIT_64 = 8, BYTE_LE = '<', BYTE_BE = '>', BYTE_AUTO = '=', TYPE_ID = {}, TYPE_ADDR = {}, TYPE_DB = {} } local pack, unpack = string.pack, string.unpack local type, pairs, tostring, setmetatable, getmetatable, error, assert, load, next, tonumber = type, pairs, tostring, setmetatable, getmetatable, error, assert, load, next, tonumber local math_type, string_dump, table_concat, string_byte, table_unpack, table_insert = math.type, string.dump, table.concat, string.byte, table.unpack, table.insert local _F = { 'c5BAA', 'c5B', 'i8', 's', 'n', 'A', 'AA', 'B', 'T', 'sB' } local _C = { node_id = 6, block_size = 4096, can_each = false, addr_size = db.BIT_32, byte_order = db.BYTE_AUTO, buffer_size = 0 } local NIL = 0 local STRING = 1 local INTEGER = 2 local DOUBLE = 3 local BOOLEAN = 4 local FUNCTION = 5 local TABLE = 6 local NUMBER = 7 local function serialize(t) local s = {} for k, v in next, t do local tp = type(k) if tp == 'string' then table_insert(s, (pack('Bs2', STRING, k))) elseif tp == 'number' then table_insert(s, (pack('Bn', NUMBER, k))) end tp = type(v) if tp == 'string' then table_insert(s, (pack('Bs4', STRING, v))) elseif tp == 'number' then if math_type(v) == 'integer' then table_insert(s, (pack('Bi8', INTEGER, v))) else table_insert(s, (pack('Bn', DOUBLE, v))) end elseif tp == 'boolean' then table_insert(s, (pack('BB', BOOLEAN, v and 1 or 0))) elseif tp == 'function' then table_insert(s, (pack('Bs4', FUNCTION, string_dump(v, true)))) elseif tp == 'table' then table_insert(s, (pack('B', TABLE))) table_insert(s, serialize(v)) table_insert(s, (pack('B', TABLE))) else table_insert(s, (pack('B', NIL))) end end return table_concat(s) end local function deserialize(b) local pos = 1 local sf = {} local stack = {} while true do local pop, pass = stack[#stack] or sf local tp, k = b:sub(pos, pos) pos = pos + 1 if tp == '' then break end tp = unpack('B', tp) if tp == NUMBER then k = unpack('n', b, pos) pos = pos + 8 elseif tp == STRING then k = unpack('s2', b, pos) pos = pos + #k + 2 else stack[#stack] = nil pass = true end if not pass then local tp, v = b:sub(pos, pos) pos = pos + 1 tp = unpack('B', tp) if tp == STRING then v = unpack('s4', b, pos) pos = pos + #v + 4 elseif tp == INTEGER then v = unpack('i8', b, pos) pos = pos + 8 elseif tp == DOUBLE then v = unpack('n', b, pos) pos = pos + 8 elseif tp == BOOLEAN then v = unpack('B', b, pos) == 1 pos = pos + 1 elseif tp == FUNCTION then v = unpack('s4', b, pos) pos = pos + #v + 4 v = load(v) elseif tp == TABLE then v = {} stack[#stack + 1] = v end pop[k] = v end end return sf end local function hash(s) if math_type(s) == 'integer' then if s > 0 then return s end end s = tostring(s) local l = #s local h = l local step = (l >> 5) + 1 for i = l, step, -step do h = h ~ ((h << 5) + string_byte(s, i) + (h >> 2)) end return h end function db.open(config) if type(config) == 'string' then config = { path = config } end for k, v in pairs(_C) do local c = config[k] if c == nil then config[k] = v end end local self = config setmetatable(self, db) local F = {} for i = 1, #_F do local v = _F[i] local _v = v:gsub('A', 'I' .. self.addr_size) F[v] = self.byte_order .. _v end self.F = F local f = io.open(self.path) if f then f:close() self:init() else self:reset() end return self end function db:reset() io.open(self.path, 'wb'):write((pack(self.F.c5BAA, 'LuaDB', db.ver, 0, 0))):close() io.open(self.path .. '.gc', 'wb'):close() io.open(self.path .. '.map', 'wb'):close() self:init() return self end function db:init() self.fw = io.open(self.path, 'r+b') self.fg = io.open(self.path .. '.gc', 'r+b') self.fm = io.open(self.path .. '.map', 'r+b') if self.buffer_size <= 0 then self.fw:setvbuf('no') self.fg:setvbuf('no') self.fm:setvbuf('no') else self.fw:setvbuf('full', self.buffer_size) self.fg:setvbuf('full', self.buffer_size) self.fm:setvbuf('full', self.buffer_size) end local s = self.fw:read(6) assert(s, 'LuaDB::数据格式错误！') assert(#s >= 6, 'LuaDB::数据格式错误！') local tag, ver = unpack(self.F.c5B, s) self.ver = ver assert(tag == 'LuaDB', 'LuaDB::数据格式错误！') assert(ver == db.ver, 'LuaDB::数据库版本不兼容！') return self end function db:pack(v) local F = self.F local tp, len, mode = type(v), 0 if v == nil then tp = 0 v = '' len = 0 elseif tp == 'string' then tp = 1 v = pack(F.s, v) len = #v elseif math_type(v) == 'integer' then tp = 2 len = 8 v = pack(F.i8, v) elseif tp == 'number' then tp = 3 len = 8 v = pack(F.n, v) elseif tp == 'boolean' then tp = 4 len = 1 v = v and '\1' or '\0' elseif tp == 'function' then tp = 5 v = pack(F.s, string_dump(v, true)) len = #v elseif getmetatable(v) == db.TYPE_DB then tp = 6 v = pack(F.AA, 0, 0) len = self.addr_size * 2 elseif tp == 'table' then tp = 7 v = pack(F.s, serialize(v)) len = #v else error('LuaDB::不支持的类型::' .. tp) end return tp, len, v end function db:unpack(addr) local F = self.F local fw = self.fw fw:seek('set', addr) local tp = unpack(F.B, fw:read(1)) if tp == 1 then local n = unpack(F.T, fw:read(8)) return fw:read(n) elseif tp == 2 then return (unpack(F.i8, fw:read(8))) elseif tp == 3 then return (unpack(F.n, fw:read(8))) elseif tp == 4 then return fw:read(1) == '\1' elseif tp == 5 then local n = unpack(F.T, fw:read(8)) return load(fw:read(n)) elseif tp == 6 then local v0 = setmetatable({}, db) for k, v in pairs(self) do v0[k] = v end v0.node_id = addr + 1 return v0 elseif tp == 7 then local n = unpack(F.T, fw:read(8)) return deserialize(fw:read(n)) end end function db:id(key) if getmetatable(key) == db.TYPE_ADDR then local o = { pointer = key.pointer, key = key.key, name = key.name, level = key.level } return setmetatable(o, db.TYPE_ID) end local po, _, _, _, _, level = self:get_pointer(key) local name = key if self.node_id > 6 then name = name:sub(self.addr_size + 1) end local o = { pointer = po, key = key, name = name, level = level } return setmetatable(o, db.TYPE_ID) end function db:load_id(key, po, level) local name = key if self.node_id > 6 then name = name:sub(self.addr_size + 1) end local o = { pointer = po, key = key, name = name, level = level } return setmetatable(o, db.TYPE_ID) end function db:addr(id) if getmetatable(id) ~= db.TYPE_ID then local po, addr, size, _, _, level = self:get_pointer(id) local name = id if self.node_id > 6 then name = name:sub(self.addr_size + 1) end local o = { pointer = po, addr = addr, key_size = size, key = id, name = name, level = level } return setmetatable(o, db.TYPE_ADDR) end local addr, size = self:get_addr(id.pointer, id.key) local o = { pointer = id.pointer, addr = addr, key_size = size, key = id.key, name = id.name, level = id.level } return setmetatable(o, db.TYPE_ADDR) end function db:get_pointer(key) local level, block_size = 0, self.block_size local addr_size = self.addr_size local hash_code = (hash(key) % block_size) + 1 key = tostring(key) if self.can_each then block_size = block_size * 2 hash_code = hash_code * 2 end block_size = block_size * addr_size hash_code = hash_code * addr_size while true do local pointer = (level * block_size) + hash_code local a, b = self:get_addr(pointer, key) if a then return pointer, a, b, key, nil, level end level = level + 1 end end function db:get_addr(pointer, key) local addr_size, F = self.addr_size, self.F local fw, fm = self.fw, self.fm fm:seek('set', pointer) local addr = fm:read(addr_size) if addr then addr = unpack(F.A, addr) else addr = 0 end if addr == 0 then return 0 else fw:seek('set', addr) local n = fw:read(8) n = unpack(F.T, n) local s = fw:read(n) if s == key then return addr, n end end end function db:new_addr(po) local F = self.F local fw, fm = self.fw, self.fm fm:seek('set', po) local n = fw:seek('end') fm:write(pack(F.A, n)) return n end function db:scan_gc(size) local F = self.F local addr_size = self.addr_size local fg = self.fg fg:seek('set') while true do local s, e = fg:read(addr_size * 2) if not s then return 0 end s, e = unpack(F.AA, s) if e - s >= size then fg:seek('cur', -addr_size * 2) fg:write(pack(F.A, s + size)) return s end end end function db:add_gc(s0, e0) local F = self.F local addr_size = self.addr_size local fg = self.fg fg:seek('set') while true do local s, e = fg:read(addr_size * 2) if not s then fg:write(pack(F.AA, s0, e0)) return self end s, e = unpack(F.AA, s) if e - s == 0 then fg:seek('cur', -addr_size * 2) fg:write(pack(F.AA, s0, e0)) return self end end end function db:tidy() local F = self.F local addr_size = self.addr_size local fg = self.fg fg:seek('set') local gc = {} while true do local s, e = fg:read(addr_size * 2) if not s then break end s, e = unpack(F.AA, s) if e - s ~= 0 then table_insert(gc, { s, e }) end end self.fg = io.open(self.path .. '.gc', 'w+b') self.fg:setvbuf('no') for i = 1, #gc do local v = gc[i] self:add_gc(v[1], v[2]) end return self end function db:check_key(k) local p = getmetatable(k) if p == db.TYPE_ID then local pointer, key = k.pointer, k.key local addr, size = self:get_addr(pointer, key) return pointer, addr, size, key elseif p == db.TYPE_ADDR then return k.pointer, k.addr, k.key_size, k.key, k end if self.node_id > 6 then k = pack(self.F.A, self.node_id) .. tostring(k) end return self:get_pointer(k) end function db:add_next(po) local F = self.F local fw, fm = self.fw, self.fm local node_id, addr_size = self.node_id, self.addr_size if self.can_each then fw:seek('set', node_id) local l = fw:read(addr_size) l = unpack(F.A, l) if l == 0 then fw:seek('cur', -addr_size) fw:write(pack(F.AA, po, po)) else l = fw:read(addr_size) l = unpack(F.A, l) fw:seek('cur', -addr_size) fw:write(pack(F.A, po)) fm:seek('set', l + addr_size) fm:write(pack(F.A, po)) end end return self end function db:set(k, v) local F = self.F local _v = v local fw, fm = self.fw, self.fm local tp, len, v = self:pack(v) local po, addr, size, k, ck = self:check_key(k) k = tostring(k) if addr == 0 then size = #k addr = self:scan_gc(len + 8 + size + 1) if addr == 0 then addr = self:new_addr(po) else fm:seek('set', po) fm:write(pack(F.A, addr)) end self:add_next(po) else fw:seek('set', addr + 8 + size) local tp, n = unpack(F.B, fw:read(1)) if tp == 1 or tp == 5 or tp == 7 then n = 8 + unpack(F.T, fw:read(8)) elseif tp == 6 then n = self.addr_size * 2 elseif tp == 2 or tp == 3 then n = 8 elseif tp == 4 then n = 1 else n = 0 end if n < len then self:add_gc(addr, addr + 8 + size + 1 + n) addr = self:scan_gc(len + 8 + size + 1) if addr == 0 then addr = self:new_addr(po) else fm:seek('set', po) fm:write(pack(F.A, addr)) end if ck then ck.addr = addr end elseif n > len then self:add_gc(addr + len + 8 + size + 1 + 1, addr + 8 + size + 1 + n) end end fw:seek('set', addr) fw:write(pack(F.sB, k, tp)) fw:write(v) if tp == 6 then local v0 for k, v in pairs(_v) do if k ~= '__call' then if not v0 then v0 = setmetatable({}, db) for k, v in pairs(self) do v0[k] = v end v0.node_id = addr + 8 + size + 1 end v0:set(k, v) end end end return self end function db:apply(args) for k, v in pairs(args) do self:set(k, v) end return self end function db:get(k) local po, addr, size = self:check_key(k) if addr == 0 then return end local v = self:unpack(addr + 8 + size) return v end function db:del(k) local _k = k local F = self.F local fw, fm = self.fw, self.fm local po, addr, size, k, ck, level = self:check_key(k) k = tostring(k) fw:seek('set', addr + 8 + size) local tp, n = unpack(F.B, fw:read(1)) if tp == 1 or tp == 5 or tp == 7 then n = 8 + unpack(F.T, fw:read(8)) elseif tp == 6 then n = self.addr_size * 2 elseif tp == 2 or tp == 3 then n = 8 elseif tp == 4 then n = 1 else n = 0 end self:add_gc(addr, addr + 8 + size + 1 + n) level = level + 1 local block_size = self.block_size local addr_size = self.addr_size local hash_code = (hash(_k) % block_size) + 1 k = tostring(_k) if self.can_each then block_size = block_size * 2 hash_code = hash_code * 2 end block_size = block_size * addr_size hash_code = hash_code * addr_size while true do local po1 = (level * block_size) + hash_code fm:seek('set', po1) local addr1 = fm:read(addr_size) if addr1 then addr1 = unpack(F.A, addr1) else addr1 = 0 end local po2 = ((level - 1) * block_size) + hash_code fm:seek('set', po2) fm:write((pack(F.A, addr1))) if addr1 == 0 then break end level = level + 1 end return self end function db:has(k) local po, addr, size = self:check_key(k) return addr > 0 end function db:fset(k, fmt, ...) return self:set(k, pack(fmt, ...)) end function db:fget(k, fmt) local t = { unpack(fmt, self:get(k)) } return table_unpack(t, 1, #t - 1) end function db:each() assert(self.can_each, 'LuaDB::each::该数据库未开启遍历！') local addr_size = self.addr_size local F = self.F local fw, fm = self.fw, self.fm local node return function() if not node then fw:seek('set', self.node_id) node = fw:read(addr_size) else fm:seek('set', node + addr_size) node = fm:read(addr_size) end if not node then return end node = unpack(F.A, node) if node == 0 then return end fm:seek('set', node) local addr = fm:read(addr_size) addr = unpack(F.A, addr) fw:seek('set', addr) local n = fw:read(8) n = unpack(F.T, n) local s = fw:read(n) local name = s if self.node_id > 6 then name = name:sub(addr_size + 1) end local o = { pointer = node, addr = addr, key_size = n, key = s, name = name } return setmetatable(o, db.TYPE_ADDR) end end function db:real_name(o) local name = o.name local n = tonumber(name) if not n then return name end if self:check_key(n) == o.pointer then name = n end return name end function db:buff(size) self.buffer_size = size or 0 if self.buffer_size <= 0 then self.fw:setvbuf('no') self.fg:setvbuf('no') self.fm:setvbuf('no') else self.fw:setvbuf('full', self.buffer_size) self.fg:setvbuf('full', self.buffer_size) self.fm:setvbuf('full', self.buffer_size) end return self end function db:flush() self.fw:flush() self.fg:flush() self.fm:flush() return self end function db:close() self.fw:close() self.fg:close() self.fm:close() return self end function db.TYPE_DB:__call(t) return setmetatable(t, self) end function db:__tostring() return string.format('LuaDB: %s', self.path) end function db.TYPE_ID:__tostring() return string.format('LuaDB @id: 0x%x', self.pointer) end function db.TYPE_ADDR:__tostring() return string.format('LuaDB @addr: 0x%x', self.addr) end db.__index = db setmetatable(db.TYPE_DB, db.TYPE_DB) return db